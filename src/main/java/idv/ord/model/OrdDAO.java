package idv.ord.model;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import javax.naming.NamingException;
import javax.sql.DataSource;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.Gson;

import idv.cart.model.CartDAO;
import idv.ord_details.model.Ord_detailsDAO;
import idv.ord_details.model.Ord_detailsVO;

public class OrdDAO implements OrdImp{
	
	private static DataSource ds = null;
	static Logger LOGGER = LogManager.getLogger(OrdDAO.class);
	static Gson gson = new Gson();
	static {
		try {
			javax.naming.Context ctx = new javax.naming.InitialContext();
			ds = (DataSource) ctx.lookup("java:comp/env/jdbc/TestMYSQL_LOCAL");
		} catch (NamingException e) {
			LOGGER.error("no DataBase defined!\n"+e.getStackTrace());
		}
	}
	
	@Override
	public OrdVO insertWithOrdDetails(OrdVO ordVO, List<Ord_detailsVO> list) {
		Connection con = null;
		PreparedStatement psmt;
		
		
		try {
			con = ds.getConnection();
			// auto commit off
			con.setAutoCommit(false);
			
			LOGGER.info("insert LOG ==================");
			LOGGER.info(gson.toJson(ordVO));
			LOGGER.info("insert LOG ==================LIST");
			LOGGER.info(gson.toJson(list));
			
			psmt = con.prepareStatement(CREATE_ONE_STMT);
			String ord_no = ordVO.getOrd_no().trim(); 
			if(ord_no.length()==0) {
				// set Error msg - ord_no must input
				throw new SQLException("ord_no is required");
			}
			psmt.setString(1, ord_no);
			psmt.setInt(2, ordVO.getCustomer_no());
			psmt.setInt(3, ordVO.getOrd_status());
			psmt.setString(4, ordVO.getReceiver());
			psmt.setString(5, ordVO.getRec_phone());
			psmt.setString(6, ordVO.getRec_zip());
			psmt.setString(7, ordVO.getRec_address());
			psmt.setInt(8, ordVO.getOrd_total());
//			psmt.setTimestamp(9, ordVO.getOrd_datetime());
			psmt.executeUpdate();
		
			// ord_no generated by made here 
			String next_ord_no = ordVO.getOrd_no();
		
			// Also insert ord_detail here
			Ord_detailsDAO details = new Ord_detailsDAO();
			Integer isdetail_insertOrd = 0 ;
			for(Ord_detailsVO alist:list) {
				alist.setOrd_no(next_ord_no);
				isdetail_insertOrd = details.insertOrd_detail(alist, con);
				if(isdetail_insertOrd==0) {
					throw new SQLException("ord_detail exception");
				}
				
			}
		
			// Commit with two table inerted
			con.commit();
			con.setAutoCommit(true);
			LOGGER.info("list size = "+list.size());
			LOGGER.info("new OrdNo - "+next_ord_no);
		} catch (SQLException e) {
			if(con != null) {
				try {
					LOGGER.error("Transaction is being rolled back-");
					con.rollback();
				} catch (SQLException e1) {
					throw new RuntimeException("rollback error occured. XX" + e1.getMessage());
				}
			}
			throw new RuntimeException("A database error occured. " + e.getMessage()); 
		} finally {
			if(con != null) {
				try {
					con.close();
					LOGGER.info("Transaction finsihed");
				} catch (SQLException e) {
					LOGGER.error("Connection closed failed!\n"+e.getStackTrace());
				}
			}
		}
		return ordVO;
	}

	@Override
	public Set<Ord_detailsVO> getOrderDetails_ByOrdno(String ord_no) {
		// TODO Auto-generated method stub
		return null;
	}
	
	@Override
	public Integer updateWithOrdDetails(OrdVO ordVO, List<Ord_detailsVO> list) {
		// cart - update  
		
		// update cart to ordered
		/*
		    update ord_status 0 - cart
		    update ord_status 1 - ordered
		 */
				
		// order list - disabled 
		return null;
	}

	@Override
	public Integer deleteWithOrdDetails(Integer ord_no, List<Ord_detailsVO> list) {
		// cart delete 
		
		// ordered  - disabled (back-end only)
		return null;
	}
	
	@Override
	public List<OrdVO> getMyOrd(Integer customer_no) {
		Connection con = null;
		PreparedStatement psmt;
		List<OrdVO> list = new LinkedList<>();
		
		try {
			con = ds.getConnection();
			psmt = con.prepareStatement(GET_ALL_STMT);
			psmt.setInt(1, customer_no);
			ResultSet rs = psmt.executeQuery();
			//ord_no,customer_no,ord_status,receiver,rec_phone,rec_zip,rec_address,ord_total,ord_datetime 
			while(rs.next()) {
				OrdVO ordVO = new OrdVO();
				ordVO.setOrd_no(rs.getString("ord_no"));//1
				ordVO.setCustomer_no(rs.getInt("customer_no"));//2
				ordVO.setOrd_status(rs.getInt("ord_status"));//3
				ordVO.setReceiver(rs.getString("receiver"));//4
				ordVO.setRec_phone(rs.getString("rec_phone"));//5
				ordVO.setRec_zip(rs.getString("rec_zip"));//6
				ordVO.setRec_address(rs.getString("rec_address"));//7
				ordVO.setOrd_total(rs.getInt("ord_total"));//8
				ordVO.setOrd_datetime(rs.getTimestamp("ord_datetime"));//9
				list.add(ordVO);
			}
		} catch (SQLException e) {
			LOGGER.error("getMyOrd Exception!\n"+e.getStackTrace());
			return null;
		} finally {
			if(con!=null) {
				try {
					con.close();
				} catch (SQLException e) {
					LOGGER.error("Connection closed failed!\n"+e.getStackTrace());
				}
			}
		}
		return list;
	}

	@Override
	public List<OrdVO> getAllOrd() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getOrdHeader() {
		Connection con = null;
		PreparedStatement psmt;
		List<String> list = new LinkedList<>();
		
		try {
			con = ds.getConnection();
			psmt = con.prepareStatement(GET_ALL_STMT);
			ResultSetMetaData rsmd = psmt.getMetaData();
			int colCount = rsmd.getColumnCount();
			for(int i=1;i<=colCount;i++) {
				String colName = rsmd.getColumnName(i);
				list.add(colName);
			}
		} catch (SQLException e) {
			LOGGER.error("getOrdHeader Exception\n"+e.getStackTrace());
		} finally {
			if(con!=null) {
				try {
					con.close();
				} catch (SQLException e) {
					LOGGER.error("Connection closed failed!\n"+e.getStackTrace());
				}
			}
		}
		return list;
	}

	
}
